/**
 * @module
 * Custom typing system used internally
 * No user need to ever interact with it. However, it is useful when hard coding type compositions outside
 * of scripting environment. It is always possible to use a vType directly instead of its composition
 */

import { LogicError, mapShape, typechecked, assert, toArray, deepDefault } from './utils'
import { IAnyType, isType, types as t } from 'mobx-state-tree'
import { string } from 'mobx-state-tree/dist/types/primitives'

/**
 *  any function
 */
export type anyFunc = (any) => any

/**
 * given a func, returns a flavor wrapper of the func
 * @typeParam func function to be wrapped
 * @typeParam flavorProps props of wrapping flavor (if complex flavor)
 * @prop flavor wrapping flavor
 */
interface funcFactory<func extends anyFunc = anyFunc, flavorProps extends object = object> {
  (flavor: componentFlavor<flavorProps>): func
}

/**
 * flavor wrapped assert function
 * @typeParam value to assert
 * @typeParam flavorProps props of wrapping flavor (if complex flavor)
 */
type assertFactory<value = any, flavorProps extends object = object> = funcFactory<assert<value>, flavorProps>

/**
 * flavor wrapped create function
 * @typeParam value to create
 * @typeParam flavorProps props of wrapping flavor (if complex flavor)
 */
type createFactory<value = any, flavorProps extends object = object> = funcFactory<create<value>, flavorProps>

/**
 * assertion function
 * @category V
 * @remark This is the workhorse of creation, and the base of any classification system, including this one..
 * Assertions are written apriori. They verify value, or throw Error class, which is converted to {@link LogicError} class
 * @remark asserts a value and returns, or throws
 * @prop value value to assert
 * @throws {@link LogicError}
 */
export interface assert<value> {
  (value: value): void
}

/**
 * create function
 * @category V
 * @remark creates type of value, after asserting it. So, it will throw per {@link assert}
 * @remark must return value of its type
 * @prop value value to create
 * @prop message if assertion fails, extends the assertion message {@see LogicError}
 * @typeParam value value
 * @returns value of its type
 * @throws {@link LogicError}
 */
export interface create<value> {
  (value: value, message?: string | string[]): value
}

/**
 * one of classifications of a type, an elementary type in this case, just a name of flavor
 * There are two kinds of flavors, complex and elementary
 * * Complex flavored type is generated by flavor factory,e.g. shape factory
 * * elementary flavored types are more fundamental,e.g. string or number
 * @typeParam flavorName literal string
 */
export type elementFlavor<flavorName extends string = string> = flavorName

/**
 * one of classifications of a type, a complex type in this case, a shape
 * There are two kinds of flavors, complex and elementary
 * * Complex flavored type is generated by flavor factory,e.g. shape factory
 * * elementary flavored types are more fundamental,e.g. string or number
 * @typeParam flavorName literal string
 * @typeParam flavorProps the props of the flavor factory that cooked the type so flavored
 */
export interface componentFlavor<flavorProps extends object = object, flavorName extends string = string> {
  flavorName: elementFlavor<flavorName>
  /**
   * complex flavors have another optional classifier, to tell the products of factory apart
   * Defaults to {@link flavorName}
   */
  typeName?: string

  /**
   * factory props take a ride on each product, so complex flavored
   */
  props: flavorProps
}

/**
 * one of classifications of a type
 * There are two kinds of flavors, complex and elementary. This is the union of both
 * * Complex flavored type is generated by flavor factory,e.g. shape factory
 * * elementary flavored types are more fundamental,e.g. string or number
 * @typeParam flavorName literal string
 * @typeParam flavorProps the props of the flavor factory that cooked the type so flavored
 */
export type flavor<flavorProps extends object = object, flavorName extends string = string> =
  | elementFlavor<flavorName>
  | componentFlavor<flavorProps, flavorName>

/**
 * describes a cast, between two types.
 * @typeParam toValue destination value, to be casted to
 */
export interface cast<toValue = any> {
  castName: string
  fromType: vClass
  /**
   * skip when hanging casts on a new type
   */
  toType?: vClass
  /**
   * casting function. fromType value in, out toType value.
   * @param fromValue typecheck is done by now
   */
  cast: (fromValue: any) => toValue
}

/**
 * flavor wrapped cast.
 * a factory that picks up flavor, and spits out a cast
 * used in building flavor factories
 * @typeParam toValue destination value, to be casted to
 * @typeParam flavorProps the props of the flavor factory, that cooked the type so flavored
 */
export interface castFactory<toValue = any, flavorProps extends object = object> {
  (flavor: flavor<flavorProps>): cast<toValue>
}

/**
 * an array
 * used in building flavor factories
 * @typeParam toValue destination value, to be casted to
 * @typeParam flavorProps the props of the flavor factory, that cooked the type so flavored
 */
export type castFactories<toValue = any, flavorProps extends object = object> = castFactory<toValue, flavorProps>[]

export type casts<toValue> = cast<toValue>[]

/**
 * vClass constructor props
 * @typeParam flavorProps the props of the flavor factory that cooked the type so flavored
 * @typeProp value
 */
interface vClass_props<value = any, flavorProps extends object = object> {
  create?: create<value>
  assert: assert<value>
  flavor?: flavor<flavorProps>
  casts?: casts<value>
}

/**
 * class representing a vType
 * @typeParam flavorProps the props of the flavor factory that cooked the type so flavored
 * @typeProp value
 */
export class vClass<value = any, flavorProps extends object = object> {
  protected readonly assertion: assert<value>
  public readonly typeName: string
  /**
   * @remark defaults to flavor name for elementary flavors
   */
  public readonly flavorName: string
  /**
   * {@link componentFlavor.props}
   */
  public readonly flavorProps: flavorProps
  public readonly flavor: flavor<flavorProps>
  public readonly casts: casts<value>
  private readonly _constructorProps: vClass_props<value, flavorProps>

  constructor(vClass_props: vClass_props<value, flavorProps>) {
    this._constructorProps = deepDefault(vClass_props, {
      flavor: { flavorName: '', props: {}, typeName: '' },
      casts: {},
      create: (value) => value,
    })

    const { assert, flavor, casts } = this._constructorProps

    this.assertion = assert
    this.flavor = flavor as flavor<flavorProps>
    // @ts-ignore
    const { flavorName, typeName = flavorName, props: flavorProps } =
      typeof flavor === 'string' ? { flavorName: flavor as elementFlavor } : (flavor as componentFlavor<flavorProps>)
    this.typeName = typeName
    this.flavorName = flavorName
    this.flavorProps = flavorProps || {}
    this.casts = (casts as casts<value>).map(({ castName, fromType, ...rest }) => ({
      castName: castName || fromType.typeName,
      toType: this,
      fromType,
      ...rest,
    })) as casts<value>
  }

  /**
   *{@link assert}
   */
  assert(value: value, errMessage: string[] | string = '') {
    try {
      this.assertion(value)
    } catch (e) {
      throw new LogicError([`bad value=${value} of flavor ${this.flavorName}`, ...toArray(errMessage || '')], e)
    }
  }

  /**
   * asserts and returns error string on negative, empty string on positive
   * @param value
   * @param message prefixes assert error message
   */
  validate(value: value, message: string | string[] = ''): string | '' {
    try {
      this.assert(value, message)
      return ''
    } catch (e) {
      return e.message
    }
  }

  /**
   * is this it?
   * @param value
   */
  is(value: value): boolean {
    try {
      this.assert(value)
      return true
    } catch (e) {
      return false
    }
  }

  /**
   * applies the casts if any match, asserts, creates and spits out
   * @param value
   * @param errMessage prefixes assert error message
   */
  create(value: value, errMessage: string[] | string = ''): value {
    const castEntry = this.casts.find(({ fromType }) => fromType.is(value))

    if (castEntry) {
      const { castName, cast, fromType } = castEntry as cast
      const castedValue = cast(fromType.create(value))
      this.assert(castedValue, [...toArray(errMessage), `bad cast ${castName}`])
      return castedValue
    }

    this.assert(value, errMessage)
    return (this._constructorProps.create as create<value>)(value)
  }

  /**
   * producers new type, refined from this one
   * @param refine refining assertion
   * @returns new refined type
   */
  refined(refine: assert<value>): vClass<value, refineFlavorProps> {
    return Refine({
      type: this as vClass<value, flavorProps>,
      refine,
    })
  }

  /**
   * producers new optional type
   * @param defaultValue
   * @returns new optional type
   */
  defaultsTo(defaultValue: value): vClass<value, optionalFlavorProps> {
    return Optional({
      type: this as vClass<value, flavorProps>,
      defaultValue,
    })
  }

  /**
   * producers new maybe type
   * @returns new maybe type
   */
  maybe(): vClass<value | undefined, maybeFlavorProps> {
    return Maybe({
      type: this as vClass<value, flavorProps>,
    })
  }

  /**
   * producers new dict type, of this type
   * @returns new dict type
   */
  dictOf(): vClass<object, dictFlavorProps> {
    return Dict({ type: this as vClass<value, flavorProps> })
  }

  /**
   * producers new union type
   * @param types union member types, along with this type
   */
  unionWith(types: vClass[]): vClass<value | any, unionFlavorProps> {
    return Union({ types: [this as vClass<any, any>, ...types] })
  }

  /**
   * producers new array type, of this type
   */
  arrayOf(): vClass<value[], arrayFlavorProps> {
    return ArrayType({ type: this as vClass<value, flavorProps> })
  }

  /**
   * returns new type with specified, extra casts
   * @param casts
   */
  setCasts(casts: casts<value> = []): vClass<value, flavorProps> {
    const { casts: oldCasts } = this._constructorProps
    return new vClass<value, flavorProps>({
      ...this._constructorProps,
      casts: { ...this._constructorProps.casts, ...casts },
    })
  }
}

/**
 * props of createVTypeFactory
 * it has almost same structure as {@link vClass_props} but all functions are wrapped in flavor,
 * being conditioned by the props of type factory being created
 */
interface createVTypeFactory_Props<value = any, flavorProps extends object = object> {
  /**
   * default values for vType factory props that are optional, as typed by {@link flavorProps}
   */
  defaultFlavorProps?: Partial<flavorProps>
  /**
   * flavor wrapped create function, to create any type of this {@link flavorName}
   */
  create?: createFactory<value, flavorProps>
  /**
   * flavor wrapped assertion, to assert any type of this {@link flavorName}
   */
  assert: assertFactory<value, flavorProps>
  /**
   * the name of this flavor. All types, produced by the type factory, will be of similar
   * flavor, same name, but different props, though same type of {@link flavorProps}, typed by flavorProps typeParam
   */
  flavorName: string
  /**
   * given flavor of new type, asserts some extra constraints on {@link flavorProps} not
   * expressed by typescript type
   * @param flavor flavor of new type, produced by type factory, the one we are constructing
   */
  flavorPropsConstraint?: (flavor: componentFlavor<flavorProps>) => void
  /**
   * array of flavor wrapped casts. Each cast is conditioned by flavor
   */
  casts?: castFactories<value, flavorProps>
}

/**
 * takes {@link flavorProps} and returns a type of the same flavor name, as specified by the parent
 * {@link createVTypeFactory_Props}, similarly flavored by {@link flavor}
 * @typeParam value value asserted by this class of similar flavored types, products of this type factory
 * @typeParam flavorProps shape of props of the type factory in making
 * @prop flavorProps shape of props needed to produce new type
 * @prop [typeName] optional name, defaults to {@link createVTypeFactory_Props.flavorName}
 * this is an extra classification available to control behavior of other constructs of this classification system
 */
export interface vTypeFactory<value = any, flavorProps extends object = object> {
  (flavorProps: flavorProps, typeName?: string): vClass<value, flavorProps>
}

/**
 * returns {@link vTypeFactory}
 * @typeParam value value asserted by this class of similar flavored types, products of this type factory
 * @typeParam flavorProps shape of props of the type factory in making
 */
export function createVTypeFactory<value = any, flavorProps extends object = object>(
  props: createVTypeFactory_Props<value, flavorProps>
): vTypeFactory<value, flavorProps> {
  const {
    defaultFlavorProps,
    assert: assertFactory,
    create: createFactory,
    casts: castFactories,
    flavorName,
    flavorPropsConstraint,
  } = deepDefault(props, {
    flavorPropsConstraint: () => {},
    defaultFlavorProps: {},
    casts: {},
    create: () => (value) => value,
  })

  const vTypeFactory: vTypeFactory<value, flavorProps> = (flavorProps, typeName?) => {
    const defaultedFlavorProps = deepDefault(flavorProps, defaultFlavorProps)
    const flavor = {
      typeName,
      flavorName,
      props: flavorProps,
    }

    flavorPropsConstraint(flavor)

    return new vClass<value, flavorProps>({
      flavor: flavor as flavor<flavorProps>,
      assert: assertFactory(flavor),
      create: createFactory(flavor),
      casts: castFactories.map((castFactory) => castFactory(flavor)),
    })
  }

  return vTypeFactory
}

export interface createVOptions<value = any> {
  typeName?: string
  casts?: casts<value>
  create?: create<value>
}

/**
 * instantiates a vType {}
 * @param assert
 * @param options
 */
export const createV = <value = any>(assert: assert<value>, options?: createVOptions<value>): vClass<value> => {
  const { typeName, casts, create } = deepDefault(options || {}, {
    typeName: '',
    casts: [],
    create: (value) => value,
  })

  return new vClass<value>({ assert, casts, create, flavor: { typeName, flavorName: typeName, props: {} } })
}

export const v = <vClass<object, any>>(
  createV((value) => assert(value instanceof vClass, `not logic type`), { typeName: 'v' })
)

export const any = createV(() => {})

const vTypeof = <value = any>(type: string): vClass<value> =>
  createV<value>((value) => typeof value === type, {
    typeName: type,
  })

export const stringType = vTypeof<string>('string')
export const functionType = vTypeof<() => any>('function')
export const numberType = vTypeof<number>('number')
export const undefinedType = vTypeof<undefined>('undefined')
export const objectType = vTypeof<object>('object')
export const booleanType = vTypeof<boolean>('boolean')
export const bigintType = vTypeof<bigint>('bigint')
export const symbolType = vTypeof<symbol>('symbol')

export interface literalFlavorProps {
  value: any
}

export const Literal = createVTypeFactory<any, literalFlavorProps>({
  assert: ({ props: { value: literalValue } }) => (value) => assert(value === literalValue, `must be ${literalValue}`),
  flavorName: 'literal',
})

export interface lateFlavorProps {
  typeFactory: () => vClass<any, any>
}

export const Late = createVTypeFactory<any, lateFlavorProps>({
  assert: ({ props: { typeFactory } }) => (value) => assert(typeFactory().is(value)),
  create: ({ props: { typeFactory } }) => (value) => typeFactory().create(value),
  flavorName: 'late',
})

export interface maybeFlavorProps {
  type: vClass
}
export const Maybe = createVTypeFactory<any, maybeFlavorProps>({
  assert: ({ props: { type } }) => (value) => {
    if (typeof value === 'undefined') return
    type.assert(value)
  },
  flavorPropsConstraint: ({ props: { type } }) => {
    assert(type.flavorName === 'maybe', 'maybe: target flavor can not be maybe')
    assert(type.flavorName === 'optional', 'maybe: target flavor can not be optional')
  },
  create: ({ props: { type } }) => (value) => {
    if (typeof value === 'undefined') return value
    return type.create(value)
  },
  flavorName: 'maybe',
})

export interface optionalFlavorProps {
  type: vClass<any, any>
  defaultValue: any
}
export const Optional = createVTypeFactory<any, optionalFlavorProps>({
  flavorPropsConstraint: ({ props: { defaultValue, type } }) => {
    assert(type.flavorName === 'maybe', 'optional: target flavor can not be maybe')
    assert(type.flavorName === 'optional', 'optional: target flavor can not be optional')
    type.assert(defaultValue, 'optional: bad default value')
  },
  assert: ({ props: { type, defaultValue } }) => (value) => {
    if (typeof value === 'undefined') return
    type.assert(value)
  },
  create: ({ props: { defaultValue, type } }) => (value) => {
    return typeof value === 'undefined' ? defaultValue : type.create(value)
  },
  flavorName: 'optional',
})

const vVoid = createV((value) => assert(typeof value === 'undefined'), { typeName: 'void' })

export interface funcFlavorProps {
  args?: vClass<any, any>[]
  result?: vClass<any, any>
}
export const Func = createVTypeFactory<(...[]) => any, funcFlavorProps>({
  defaultFlavorProps: { args: [], result: any },
  assert: () => (func) => assert(typeof func === 'function', `not function type`),
  create: ({ props: { args = [], result = any } }) => (func) => typechecked(args, result)(func) as (...[]) => any,
  flavorName: 'func',
})

export interface refineFlavorProps {
  type: vClass<any, any>
  refine: (any) => void
}

export const Refine = createVTypeFactory<any, refineFlavorProps>({
  assert: ({ props: { type, refine } }) => (value) => {
    type.assert(value)
    refine(value)
  },
  create: ({ props: { type } }) => (value) => type.create(value),
  flavorName: 'refine',
})

export interface selfishHelper {
  (self: object): any
}
export interface selfishHelpers {
  [name: string]: selfishHelper
}

interface propTypes {
  [propName: string]: vClass
}

export interface shapeFlavorProps {
  propTypes: propTypes
  helpers?: selfishHelpers
  isStrict?: boolean
}

const assertShape = (flavor: componentFlavor<shapeFlavorProps>) => {
  const {
    props: { propTypes, isStrict },
  } = flavor

  const assertNoExtraProps: assert<object> = (shape) => {
    const extraEntries = Object.entries(shape).filter(([propName]) => !propTypes[propName])
    assert(!extraEntries.length, `shape=${shape}: extra props ${extraEntries}`)
  }

  return (shape) => {
    assert(typeof shape === 'object', 'not an object')

    const errMessages = Object.entries(propTypes).map(([propName, propType]) => {
      try {
        propType.assert(shape[propName])
      } catch (e) {
        return e.message
      }

      return ''
    })

    assert(
      !errMessages.length,
      `shape=${shape}: bad or missing props
     ${new LogicError(errMessages).message}`
    )

    isStrict && assertNoExtraProps(shape)
  }
}

export const Shape = createVTypeFactory<object, shapeFlavorProps>({
  defaultFlavorProps: {
    propTypes: {},
    isStrict: true,
    helpers: {},
  },
  assert: assertShape,
  create: ({ props: { propTypes, helpers } }) => (shape: { [key: string]: any }) => {
    const helperSpecs = mapShape(helpers as selfishHelpers, (helper) => ({
      get: () => helper(self),
      enumerable: false,
    }))

    const propSpecs = mapShape(shape, (prop, propName) => ({
      value: propTypes[propName].create(prop, `bad prop ${propName}`),
    }))

    const self = Object.create({}, propSpecs)
    Object.defineProperties(self, helperSpecs)
    return Object.freeze(self)
  },
  flavorName: 'shape',
})

export interface dictFlavorProps {
  type?: vClass
}
export const Dict = createVTypeFactory<object, dictFlavorProps>({
  defaultFlavorProps: {
    type: any,
  },
  assert: ({ props: { type } }) => (shape) => {
    objectType.assert(shape)
    const errMessages: string[] = Object.entries(shape).reduce((messages: string[], [name, prop]) => {
      const errMessage = (type as vClass).validate(prop, `bad prop ${name}`)
      return errMessage ? [...messages, errMessage] : messages
    }, [])
    assert(!errMessages.length, errMessages)
  },
  create: ({ props: { type } }) => (shape: { [key: string]: any }) => {
    const self = mapShape(shape, (prop) => (type as vClass).create(prop))
    return Object.freeze(self)
  },
  flavorName: 'dict',
})

const findType = (types: vClass[]) => (value) => types.find((vType) => vType.is(value))

export interface unionFlavorProps {
  types: vClass[]
}

export const Union = createVTypeFactory<any, unionFlavorProps>({
  assert: ({ props: { types } }) => (value) => assert(!!findType(types)(value), `does not match any types in union`),
  create: ({ props: { types } }) => (value) => (findType(types)(value) as vClass).create(value),
  flavorName: 'union',
})

export const array = createV((value) => assert(Array.isArray(value), 'not an array'))

export interface arrayFlavorProps {
  type: vClass
}

export const ArrayType = createVTypeFactory<any[], arrayFlavorProps>({
  defaultFlavorProps: {
    type: any,
  },
  assert: ({ props: { type } }) => (arr) => {
    array.assert(arr)
    arr.forEach((element, index) => type.assert(element, `bad array element index=${index}`))
  },
  create: ({ props: { type } }) => (arr) => arr.map((element, index) => type.create(element)),
  flavorName: 'array',
})

export interface tupleFlavorProps {
  types: vClass<any>[]
}

export const Tuple = createVTypeFactory<any[], tupleFlavorProps>({
  assert: ({ props: { types } }) => (arr) => {
    array.assert(arr)
    assert(arr.length === types.length, `bad array length length=${arr.length}, must be ${types.length}`)
    types.forEach((vElement, index) => vElement.assert(arr[index], `bad element index=${index}`))
  },
  create: ({ props: { types } }) => (arr) => arr.map((element, index) => types[index].create(element)),
  flavorName: 'tuple',
})

export interface jsonFlavorProps {
  type: vClass
}

export const Json = createVTypeFactory<string, jsonFlavorProps>({
  assert: ({ props: { type } }) => (json) => {
    stringType.assert(json, `value must be string`)
    assert(() => JSON.parse(json))

    const jsonValue = (() => {
      try {
        return JSON.parse(json)
      } catch (e) {
        throw new LogicError('', e)
      }
    })()

    type.assert(jsonValue)
  },
  flavorName: 'json',
})
