This is the birds eye view. 
Iv chosen to immitate a preexisting abstraction, 
if it might seem a little intricate, i blame that guy.

###### Its a particle zoo, thats the abstraction.
There are classes of particles, e.g. a block class, and it includes all kinda different blocks. So,  group
is a collective of similar particles.

###### A particle.
Is really a type that produces its instances, particle elements, the matter itself, like a photon produces packets of light. So, a block particle is
a type of block, a model.  Happens to be a serializable mst model, in one of its representations, and that model 
produces block instances, nodes of mobx state tree.

So, whats inside a particle object is different descriptions of what it is typing, expressed in a variety of typing systems 
appropriate for the use case.

###### a particle class
Its literally a class that instantiates an object,a particle of that class, given a description, one of representations of a particle.
It creates all the faces, representations of what particle stands for, the particle element.  So, theres a block spec referencing all kinds of other 
particles composing it, and the structure of that composition comes from the law governing block particle class.

###### particle laws
They are the laws of nature, but thats too dramatic. Theres a law for each particle class, then each particle generates a 
ton of its copies. Just refreshing.

So, the law is a class factory, the particle class factory. Just a func that spits out a particle class.

###### the grand unifying law of nature
Thats the most boring part of the whole scheme. Its just a generic, most basic low of nature, producing 
the most basic particle class with particles that are totally useless and not fertile. 

Yep, it produces vacuum, which spawns all the complexity.

But, that vacuum law contains the mechanism of particle class creation common to all laws and particle classes
in all the instances of logic engine. It is a function that is extended to produce all particle classes known
in all logic universes.

###### More on particles.
They produce not just elements, but components. Components are functions that produce a particle of a class.
They live in the same namespace as particles of a class, as equals. They are very useful and necessary for a consistent, 
or complete logic system.  So, a particle law also describes how components of a particle class render their 
particles, but not completely. Each component of a class can extend the class boilerplate. e.g. blocks can be 
generated by block components, consuming some props.

###### Why the zoo?
Because composition. all the matter is composed of particle elements. Particles do the composition, when right stuff 
gets together. That stuff is other elements.  Particle law defines the type of composition.

###### Logic engine
Is a complete logic system. It contains its custom particle classes in particle collections. It can import
particles and particle classes from other instances of logic engines. It can export some of its partciles and 
particle classes, to be imported into other engines. 

Logic engines are serializable models.

###### Particle collections.
Are collections of particles of same class, like blocks, or flavors. Some of the particles in a 
collection can live as volatile hard code, and some can be scripted as a serializable string. 

Scripts are executed inside a secure virtual machine, a sandbox

A particle of a class can be cast between volatile and persistent, living under the same name.

###### Flavor particle class.
Is a built in particle class. Its basically metadata. Some flavors are supplied as  prebuilt,  other
flavors can be added in each logic engine, and shared as other particles.  The metadata a flavor types 
can be rent on particle use, perhaps a usage fee for each instantiation.It can contain a description.
It can be composed of other flavors. Flavors can be used as a tagging system, e.g. providing context
to collections of particle elements crossing composition borders between elements. e.g. different blocks
can have pins of same flavor, or have common flavor composing spices.

###### BUT, THE MOST BASIC OF QUESTIONS - whats a type
That would answer what a particle stands for, cos its a type.  Type is a way to tell something from anything 
else, thats all. Also, types are useful as a warehouse of meta for those it types, including some behaviour, 
as funcs. It, basically describes a few what if scenarious, for something we can isolate from the chaos around us.
Its a pattern, a ghost, in the eye of beholder.

And how do we define types?  By rejecting anything thats not the type. Whats left is it. Its a fuzzy concept,
definition by exclusion. The engine of that is assert function. So, every time you crate a stereotype, an assertion,
you are creating a particle. In human world its called a mem. A profile of a human, like a selfless dogooder, is a 
particle, a human particle of kindness. When its refined by another type, a hippy chic, it becomes a graviton that
glues us all into a rainbow tribe.







